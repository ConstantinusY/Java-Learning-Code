# 七、JavaSE——数据结构与算法

## 1 数据结构基础（no code)

### 1.1 什么是数据结构

数据结构（data structure）是指**相互间存在一种或多种特定关系的数据元素的集合。**是组织并存储数据以便能够有效使用的一种专门格式，它用来反映一个数据的内部构成，即一个数据由那些成分数据构成，以什么方式构成，呈什么结构。 

由于信息可以存在于逻辑思维领域，也可以存在于计算机世界，因此作为信息载体的数据同样存在于两个世界中。 

表示一组数据元素及其相互关系的数据结构同样也有两种不同的表现形式， 

+ **数据结构的逻辑层面，即数据的逻辑结构；** 
+ **存在于计算机世界的物理层面，即数据的存储结构。** 

**数据结构=逻辑结构+存储结构+（在存储结构上的）运算/操作** 

------------



### 1.2 数据的逻辑结构 

数据的逻辑结构指数据元素之间的逻辑关系（和实现无关）。 
逻辑结构主要分为三种结构：**线性结构、树状结构、网状结构(图)** 

线性结构：有且只有一个开始结点和一个终端结点，并且所有结点都最多只有一个直接前驱和一个直接后继。 
线性表就是一个典型的线性结构，它有四个基本特征：   

+ 集合中必存在**唯一的一个"第一个元素"；** 
+ 集合中必存在**唯一的一个"最后的元素"；** 
+ 除最后元素之外，其它数据元素均有唯一的**"直接后继"；** 
+ 除第一元素之外，其它数据元素均有唯一的**"直接前驱"。** 

**数据元素之间存在着"一对一"的线性关系的数据结构。** 

![线性结构](https://img-blog.csdnimg.cn/20210314110114542.png)

树状结构：除了第一个数据元素（元素 01）以外每个数据元素有且仅有一个直接前驱元素，但是可以有多个直接后续元素。 
**数据元素之间是 1 对 多的联系** 

![树状结构](https://img-blog.csdnimg.cn/20210314110141649.png)



网状结构：每个数据元素可以有多个直接前驱元素，也可以有多个直接后续元素。

**数据元素之间是多对 多 的联系** 

![网状结构](https://img-blog.csdnimg.cn/20210314110201374.png)

--------------



### 1.3 数据的存储结构 

数据的存储结构主要包括数据元素本身的存储以及数据元素之间关系表示，是数据的逻辑结构在计算机中的表示。包括 **顺序存储、链式存储、索引存储，以及散列存储**四种。 



顺序存储结构：**把逻辑上相邻的节点存储在物理位置上相邻的存储单元中，结点之间的逻辑关系由存储单元的邻接关系来体现。** 
由此得到的存储结构为顺序存储结构，通常顺序存储结构是借助于编程语言的数组来描述的。

（数据元素的存储对应于一块连续的存储空间，数据元素之间的前驱和后续关系通过数据元素，在存储器中的相对位置来反映） 

![顺序存储结构](https://img-blog.csdnimg.cn/20210314110237673.png)



链式存储结构：**数据元素的存储对应的是不连续的存储空间，每个存储节点对应一个需要存储的数据元素。每个结点是由数据域和指针域组成。元素之间的逻辑关系通过存储节点之间的链接关系反映。逻辑上相邻节点物理上不必相邻。**   

![链式存储结构](https://img-blog.csdnimg.cn/20210314110248980.png)



索引存储结构：**除建立存储结点信息外，还建立附加的索引表来标识结点的地址。** 

![索引存储结构](https://img-blog.csdnimg.cn/20210314110304374.png)



散列存储结构：根**据结点的关键字直接计算出该结点的存储地址**，比如Java中的HashSet、HashMap底层就是散列存储结构。这是一种神奇的结构，添加、查询速度快。 

![散列存储结构](https://img-blog.csdnimg.cn/20210314110330729.png)

注意：

+ 同一逻辑结构可以对应多种存储结构。 
+ 同样的运算，在不同的存储结构中，其实现过程是不同的 

-------------------



### 1.4 线性表

线性表是n个类型相同数据元素的有限序列，通常记作（a<sub>0</sub> , a<sub>1</sub> , …a<sub>i-1</sub> , a<sub>i</sub> , a<sub>i+1</sub> …,a<sub>n-1</sub>）。 

1. **数据类型相同**  
   **从a<sub>0</sub>到a<sub>n-1</sub>的n个数据元素是具有相同属性的元素。** 
   比如说可都是数字，例如(23, 14, 66, 5, 99)；也可以是字符，例如(A, B, C, … Z)； 
   当然也可以是具有更复杂结构的数据元素，例如学生、商品、装备。
2. **序列(顺序性)** 
   **相同数据类型意味着在内存中存储时，每个元素会占用相同的内存空间**，**便于后续的查询定位。** 
   在线性表的相邻数据元素之间存在着**序偶关系**， 
   即a<sub>i-1</sub>是a<sub>i</sub>的直接前驱，则a<sub>i</sub>是a<sub>i-1</sub>的直接后续，同时a<sub>i</sub>又是a<sub>i+1</sub>的直接前驱，a<sub>i+1</sub>是a<sub>i</sub>的直接后续。 
   <br />唯一没有直接前驱的元素**a<sub>0</sub>称为表头**，唯一没有后续的元素**a<sub>n-1<sub>称为表尾。** 
   除了表头和表尾元素外，任何一个元素都**有且仅有一个**直接前驱和直接后继。 
3. 有限 
   **线性表中数据元素的个数n定义为线性表的长度，n是一个有限值。** 
   **当n=0 时线性表为空表。** 
   在非空的线性表中每个数据元素在线性表中都有唯一确定的 序号，
   例如a<sub>0</sub>的序号是0，a<sub>i</sub>的序号是i。 
   在一个具有n(n＞0)个数据元素的线性表中，数据元素序号的范围是[0, n-1]。 



线性表的逻辑结构如图所示： 

![线性表的逻辑结构](https://img-blog.csdnimg.cn/20210314110114542.png)

线性表逻辑结构对应的顺序存储结构为顺序表，对应的链式存储结构为链表。 

### 1.5 顺序表----顺序存储结构 

![顺序表](https://img-blog.csdnimg.cn/20210314110237673.png)

特点：**在内存中分配连续的空间，只存储数据，不需要存储地址信息。位置就隐含着地址。** 

优点： 

1. **节省存储空间**，因为分配给数据的存储单元全用存放结点的数据（不考虑c/c++语言中数组需指定大小的情况），结点之间的逻辑关系没有占用额外的存储空间。 

2. **索引查找效率高**，即每一个结点对应一个序号，由该序号可以直接计算出来结点的存储地址。 <br/>
   假设线性表的每个数据元素需占用K个存储单元，并以元素所占的第一个存储单元的地址作为数据元素的存储地址。则线性表中序号为i的数据元素的存储地址LOC(a<sub>i</sub>)与序号为i+1 的数据元素的存储地址LOC(a<sub>i+1</sub>)之间的关系为 

$$
LOC (a_{i+1}) = LOC(a_i)+ K
$$

通常来说，线性表的i号元素a<sub>i</sub>的存储地址为
$$
LOC(a_i)= LOC(a_0)+ i\times K
$$
其中LOC(a<sub>0</sub>)为 0 号元素a<sub>0</sub>的存储地址，通常称为线性表的起始地址。 

缺点： 

1. 插入和删除操作需要移动元素，效率较低。

![顺序表的插入和删除](https://img-blog.csdnimg.cn/20210314113502925.png)

2. 必须提前分配固定数量的空间，如果存储元素少，可能导致空间浪费。 
3. 按照内容查询效率低，因为需要逐个比较判断

------

<br/><br/>

### 1.6 链表----链式存储结构 

![链表](https://img-blog.csdnimg.cn/20210314110248980.png)

特点：**数据元素的存储对应的是不连续的存储空间**，**每个存储结点对应一个需要存储的数据元素。每个结点是由数据域和指针域组成。 元素之间的逻辑关系通过存储节点之间的链接关系反映出来。逻辑上相邻的节点物理上不必相邻。**   

缺点： 
1、**比顺序存储结构的存储密度小** (每个节点都由数据域和指针域组成，所以相同空间内假设全存满的话顺序比链式存储更多)。   
2、**查找结点时链式存储要比顺序存储慢**（每个节点地址不连续、无规律，导致按照索引查询效率低下）。 

优点： 
1、**插入、删除灵活** (不必移动节点，只要改变节点中的指针，但是需要先定位到元素上)。 
2、**有元素才会分配结点空间，不会有闲置的结点。** 

在使用单链表实现线性表的时候，**为了使程序更加简洁，我们通常在单链表的最前面添加一个哑元结点，也称为头结点。** 
在头结点中不存储任何实质的数据对象，其 next 域指向线性表中 0 号元素所在的结点， 
可以对**空表、非空表的情况**以及**对首元结点进行统一处理**，**常用头结点,编程更方便。** 
 一个带头结点的单链表实现线性表的结构图如图 所示。

 ![带头结点的单链表](https://img-blog.csdnimg.cn/20210314113637507.png)

--------------

<br/><br/>

### 1.7 其他链表

**双向链表** 
单链表一个优点是结构简单，但是它也有一个缺点，即**在单链表中只能通过一个结点的引用访问其后续结点，而无法直接访问其前驱结点。**

要在单链表中找到某个结点的前驱结点，必须从链表的首结点出发依次向后寻找，但是需要Ο(n)时间。 

为此我们可以扩展单链表的结点结构，使得**通过一个结点的引用，不但能够访问其后续结点，也可以方便的访问其前驱结点。** 

扩展单链表结点结构的方法是，在单链表结点结构中新增加一个域，该域用于指向结点的直接前驱结点。 扩展后的结点结构是构成双向链表的结点结构如图所示。 

![扩展的单链表节点](https://img-blog.csdnimg.cn/20210314113951185.png)

双向链表是通过上述定义的结点使用 pre 以及 next 域依次串联在一起而形成的。一个双向链表的结构如图所示。 

![双向链表](https://img-blog.csdnimg.cn/2021031411401953.png)

在双向链表中同样需要完成数据元素的查找、插入、删除等操作。**在双向链表中进行查找与在单链表中类似，只不过在双向链表中查找操作可以从链表的首结点开始，也可以从尾结点开始**，但是需要的时间和在单链表中一样 
Java中的LinkedList底层使用的就是双向链表。
<br/>
**循环链表** 

在一个循环链表中, **首节点和末节点被连接在一起**。这种方式**在单向和双向链表中皆可实现**。要遍历一个循环链表，你开始于任意一个节点然后沿着列表的任一方向直到返回开始的节点。循环链表可以被视为"无头无尾"。 

**循环链表中第一个节点之前就是最后一个节点**，反之亦然。 

循环链表的无边界使得在这样的链表上**设计算法会比普通链表更加容易**。 

对于新加入的节点应该是在第一个节点之前还是最后一个节点之后可以根据实际要求灵活处理，区别不大。 

单向链表的循环带头结点的非空链表

![单向链表的循环带头结点的非空链表](https://img-blog.csdnimg.cn/20210314114303994.png)

单向链表的循环带头结点的空链表 

![单向链表的循环带头结点的空链表 ](https://img-blog.csdnimg.cn/20210314114320572.png)

双向链表的循环带头结点的非空链表

![双向链表的循环带头结点的非空链表](https://img-blog.csdnimg.cn/20210314114329615.png)

双向链表的循环带头结点的空链表 

![双向链表的循环带头结点的空链表 ](https://img-blog.csdnimg.cn/20210314114340413.png)

------------------

<br/><br/>

### 1.8 栈

栈的定义 
栈（stack ）又称堆栈，它是**运算受限的线性表**。其限制是**仅允许在表的一端进行插入和删除操作，不允许在其他任何位置进行插入、查找、删除等操作。** 

表中进行插入、删除操作的一端称为 **栈顶**（top），栈顶保存的元素称为栈顶元素。相对的，表的另一端称为**栈底**（bottom） 

**当栈中没有数据元素时称为空栈** 

向一个栈插入元素又称为 **进栈或 入栈** push
从一个栈中删除元素又称为 **出栈或 退栈**  pop

由于栈的插入和删除操作仅在栈顶进行，后进栈的元素必定先出栈。

所以又把堆栈称为 **后进先出表**（Last In First Out，简称 **LIFO**） 

-------------





### 1.9队列

队列（queue）简称队，它同堆栈一样，也**是一种运算受限的线性表**，其限制是**仅允许在表的一端进行插入，而在表的另一端进行删除。** 

在队列中把插入数据元素的一端称为 **队尾**（rear），删除数据元素的一端称为**队首**（front）。 

向队尾插入元素称为 **进队或入队**，新元素入队后成为新的队尾元素
从队列中删除元素称为**离队或出队**，元素出队后，其后续元素成为新的队首元素。 

由于队列的插入和删除操作分别在队尾和队首进行，每个元素必然按照进入的次序离队，也就是说先进队的元素必然先离队，所以称队列为 **先进先出表**（First In First Out,简称**FIFO**）。 

-------------





### 1.10 双端队列deque 

所谓双端队列(double ended queue >> deque)是指**两端都可以进行进队和出队操作的队列**，如下图所示，将队列的两端分别称为前端和后端，两端都可以入队和出队。其元素的逻辑结构仍是线性结构 

![双端队列](https://img-blog.csdnimg.cn/20210314115455128.png)

在双端队列进队时：前端进的元素排列在队列中后端进的元素的前面，后端进的元素排列在队列中前端进的元素的后面。在双端队列出队时，无论前端出还是后端出，先出的元素排列在后出的元素的前面。

**输出受限的双端队列**，即一个端点允许插入和删除，另一个端点只允许插入的双端队列。 
                
![输出受限的双端队列](https://img-blog.csdnimg.cn/20210314115543232.png)

**输入受限的双端队列**，即一个端点允许插入和删除，另一个端点只允许删除的双端队列。 
          
![输入受限的双端队列](https://img-blog.csdnimg.cn/2021031411555582.png)

双端队列既可以用来队列操作，也可以用来实现栈操作（只操作一端就是栈了） 

--------------





###  1.11 树 

树是由一个集合以及在该集合上定义的一种关系构成的。**集合中的元素称为树的结点**，所定义的关系称为**父子关系。** 

**父子关系在树的结点之间建立了一个层次结构。** 

树的结点包含一个数据元素及若干指向其子树的若干分支。

在这种层次结构中有一个结点具有特殊的地位，这个结点称为该树的根结点，或简称为树根。 

我们可以形式地给出树的递归定义如下： 
树（tree ）是 n（n ≥ 0）个结点的有限集。它可能是

+ 一棵空树（n = 0），空树中不包含任何结点。 
+ 一棵非空树（n > 0），此时有且仅有一个特定称为根（root ）的结点； 

当n > 1 时，其余结点可分为m（m > 0）个互不相交的有限集T<sub>1</sub> ，T<sub>2</sub> ，…，T<sub>m</sub> ，其中每一个本身又是一棵树，并且称为根的 子树（sub tree）。 

![树](https://img-blog.csdnimg.cn/20210314121233548.png)

如图 （a）是一棵空树、（b）是只有一个根节点的树、（c）是一棵有 10个结点的树，其中A是根，

其余的结点分成 3 个不相交的集合：T1 ={B,E,F}、T2 ={C,G}、T3 ={D,H,I,J}，每个集合都构成一棵树，且都是根A的子树。 

---------------





### 1.12 结点的度与树的度 

**结点拥有的子树的数目称为结点的度（Degree）。** 

度为0的结点称为**叶子（leaf ）或终端结点**。度不为 0 的结点称为 **非终端结点或 分支结点**。除根之外的分支结点也称为内部结点。 

**树内各结点的度的最大值称为树的度。**

父亲、儿子、兄弟 

1. **父亲（parent）：一个结点的直接前驱结点** 
2. **儿子（child）：一个结点的直接后继结点** 
3. **兄弟（sibling） ：同一个父亲结点的其他结点** 

结点 A 是结点 B、C、D 的父亲，结点 B、C、D 是结点 A 的孩子。 

由于结点 H、I、J 有同一个父结点 D，因此它们互为兄弟。 

祖先、子孙、堂兄弟 
将父子关系进行扩展，就可以得到祖先、子孙、堂兄弟等关系。 
结点的 祖先是从根到该结点路径上的所有结点。 
以某结点为根的树中的任一结点都称为该结点的 子孙。 
父亲在同一层次的结点互为 堂兄弟 

-------------



### 1.13 二叉树

**每个结点的度均不超过 2 的有序树，称为 二叉树（binary tree） 。** 
与树的递归定义类似，二叉树的递归定义如下： 
二叉树或者是一棵空树，或者是一棵由一个根结点和两棵互不相交的分别称为根的左子树和右子树的子树所组成的非空树。 
![二叉树](https://img-blog.csdnimg.cn/20210314121521772.png)

由以上定义可以看出， 
**二叉树中每个结点的孩子数只能是 0、1 或 2 个，并且每个孩子都有左右之分。** 

位于左边的孩子称为左孩子，位于右边的孩子称为右孩子；

以左孩子为根的子树称为左子树，以右孩子为根的子树称为右子树。 

![二叉树的其他情况](https://img-blog.csdnimg.cn/20210314122847616.png)

**满二叉树：** 
**高度为k并且有 2<sup>k+1</sup> -1 个结点的二叉树。** 
满二叉树中，每层结点都达到最大数，即每层结点都是满的，因此称为满二叉树。 

**完全二叉树：** 
**若在一棵满二叉树中，在最下层从最右侧起去掉相邻的若干叶子结点，得到的二叉树即为完全二叉树。** 

**满二叉树必为完全二叉树，而完全二叉树不一定是满二叉树** 

![满二叉树和完全二叉树](https://img-blog.csdnimg.cn/20210314123010927.png)

**二叉树的存储结构** 
二叉树存储结构有两种：顺序存储结构和链式存储结构。更多使用链式存储结构 

**链式存储结构** 

![三域节点，四域节点，二叉链表，三叉链表](https://img-blog.csdnimg.cn/20210314123137439.png)
设计不同的结点结构可构成不同的链式存储结构。 

在二叉树中每个结点都有两个孩子，则可以设计每个结点至少包括 3 个域：数据域、左孩子域和右孩子域。 

数据域存放数据元素，左孩子域存放指向左孩子结点的指针，右孩子域存放指向右孩子结点的指针。如图 （a）所示。 

利用此结点结构得到的二叉树存储结构称为**二叉链表。** 

为了方便找到父结点，可以在上述结点结构中增加一个指针域，指向结点的父结点。如图 （b）所示。 
采用此结点结构得到的二叉树存储结构称为**三叉链表。** 
        

--------------------





### 1.14 查找树

**二叉查找/搜索/排序树  BST**  (binary search/sort tree) 
![查找树](https://img-blog.csdnimg.cn/20210314123307577.png)
或者是一棵**空树**； 
或者是**具有下列性质的二叉树**： 

+ 若它的左子树不空，则左子树上所有结点的值均小于它的根节点的值； 
+ 若它的右子树上所有结点的值均大于它的根节点的值； 
+ 它的左、右子树也分别为二叉排序树。

注意：**对二叉查找树进行中序遍历，得到有序集合。** 

----------------





### 1.15 平衡二叉树

**平衡二叉树（Self-balancing binary search tree）  自平衡二叉查找树  又被称为AVL树（有别于AVL算法）**
![平衡二叉树](https://img-blog.csdnimg.cn/20210314123456123.png)
它可能是一棵空树 

它若非空，**左右两个子树的高度差(平衡因子)的绝对值不超过1， 并且左右两个子树都是一棵平衡二叉树，** 

同时，**平衡二叉树必定是二叉搜索树，反之则不一定** 

平衡因子（平衡度）：结点的平衡因子是结点的左子树的高度减去右子树的高度。（或反之定义） 

平衡二叉树：每个结点的平衡因子都为 1、－1、0 的二叉排序树。或者说每个结点的左右子树的高度最多差1的二叉排序树。

平衡二叉树的目的是为了**减少二叉查找树层次，提高查找速度** 

平衡二叉树的常用实现方法有AVL、红黑树、替罪羊树、Treap、伸展树等 

------------




### 1.16 红黑树 

**R-B Tree，全称是Red-Black Tree，又称为"红黑树"，它一种平衡二叉树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。** 
![红黑树](https://img-blog.csdnimg.cn/20210314124310891.png)

红黑树的特性: 

1. 每个节点或者是黑色，或者是红色。 
2. 根节点是黑色。 
3. 每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！
4. 如果一个节点是红色的，则它的子节点必须是黑色的。 
5. 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。 

**注意：** 

+ 特性3中的叶子节点，是只为空(NIL或null)的节点。 
+ 特性5，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树 

红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是O(log(N))，效率非常之高。 
它虽然是复杂的，但最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在O(log(n))时间内做查找，插入和删除，这里的n 是树中元素的数目。 

Java集合中的TreeSet和TreeMap，C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。 

------------------



### 1.17 图

1.图的基本概念：多对多关系 

图（graph）是一种网状数据结构，图是由非空的顶点集合和一个描述顶点之间关系的集合组成。 
其形式化的定义如下： 
$$
Graph = ( V , E ) 
$$

$$
V = \lbrace x| x \in DObj \rbrace
$$

$$
E = \lbrace u，v | P(u , v)^{u,v\in V} \rbrace
$$

V 是具有相同特性的数据元素的集合，V 中的数据元素通常称为**顶点（Vertex）**， 
**E 是两个顶点之间关系的集合。P(u , v)表示 u 和 v 之间有特定的关联属性。** 
DObj是一个**数据对象**

**若<u , v>∈E，则<u , v>表示从顶点 u 到顶点 v 的一条弧，并称 u 为弧尾或起始点，称v 为弧头或终止点， 此时图中顶点之间的连线是有方向的，这样的图称为有向图（directedgraph）。** 

**若<u , v>∈E 则必有<v , u>∈E，即关系 E 是对称的，此时可以使用一个无序对(u , v)来代替两个有序对， 它表示顶点 u 和顶点 v 之间的一条边，此时图中顶点之间的连线是没有方向的，这种图称为 无向图（undirected graph）。** 

在无向图和有向图中 V 中的元素都称为顶点，而顶点之间的关系却有不同的称谓，即弧或边，为避免麻烦，在不影响理解的前提下，我们统一的将它们称为 边（edge） 。 
并且我们还约定**顶点集与边集都是有限的，并记顶点与边的数量为|V|和|E|。** 

**无向图实际上也是有向图，是双向图**

![无向图，有向图](https://img-blog.csdnimg.cn/2021031413002089.png) 

----------------------



### 1.18 加权图

![加权图](https://img-blog.csdnimg.cn/20210314130149802.png)
在实际应用中，图不但需要表示元素之间是否存在某种关系 
而且图的边往往与具有一定实际意义的数有关，即**每条边都有与它相关的实数，称为权。** 
这些权值可以表示从一个顶点到另一个顶点的距离或消耗等信息，在本章中假设边的权均为正数。 
这种边上具有权值的图称为 **带权图（weighted graph）** 

---------------



### 1.19 **图的存储结构** 

可以采用顺序存储结构和链式存储结构，更多采用链式存储结构 
邻接表：链表  链式存储结构 

--------



## 2\.  算法初探

### 2.1 什么是排序？

排序（sorting）的功能是将一个数据元素的任意序列，重新排列成一个按关键字有序的序列。



![image-20210321112413153](https://i.loli.net/2021/03/21/WvcLIheCnwJsAl5.png)

**内部排序和外部排序**

一类是整个排序过程在内存储器中进行，称为内部排序；

另一类是由于待排序元素数量太大，以至于内存储器无法容纳全部数据，排序需要借助外部存储设备才能完成，这类排序称为外部排序。

本章介绍的排序方法都属于内部排序

 

**比较排序和非比较排序**

​	大部分排序都是需要通过比较首先来判断大小，作为排序的依据的。

但是也有例外的，比如计数排序、基数排序，不需要进行比较。效率可以做到更高，但是会有一些限制条件，也可能需要更多的空间。

冒泡排序、选择排序、直接插入排序是最基本的三种排序，效率最低，但是算法简单。排序的学习一般从这三种排序算法开始。

-------------------



### 2.2 冒泡排序

冒泡排序的算法

1. 整个数列分成两部分：前面是无序数列，后面是有序数列
2. 初始状态下，整个数列都是无序的，有序数列是空
3. 如果一个数列有n个元素，则至多需要n-1趟循环才能保证数列有序
4. 每一趟循环可以让无序数列中最大数排到最后，（也就是说有序数列的元素个数增加1）
5. 每一趟循环都从数列的第一个元素开始进行比较，依次比较相邻的两个元素，比较到无序数列的末尾即可（而不是数列的末尾）
6. 如果前一个大于后一个，交换

code:

```java
import java.util.Arrays;

public class code01 {
    public static void bubbleSort(int[] input){
        for(int i = 0; i< input.length-1; i++){
            for (int j = 0; j < input.length-1; j++){
                if(input[j] > input[j+1]){
                    int temp = input[j+1];
                    input[j+1] = input[j];
                    input[j] = temp;
                }
            }
        }
    }
    public static void main(String[] args) {
        int[] arr = {123,43,21,6,897,657,5,34,233};
        System.out.println("排序前数组："+ Arrays.toString(arr));
        bubbleSort(arr);
        System.out.println("排序后数组："+ Arrays.toString(arr));
    }
}
```

-------------------



### 2.3  优化冒泡排序

缺点1：每一趟比较都要比较到数组的最后，没有必要，只要比较到无序数列的最后即可

解决：`内层循环计数变量<排序数组.length-1 `修改为` 内层循环计数变量<排序数组.length-1-外层循环计数变量`   



缺点2：不管是否有序，都要进行n-1趟循环；

添加对有序的判断：比较了一趟，没有发生交换，即已经有序

解决：定义一个符号量`flag`，默认有序true；发生交换，置为false，

一趟循环结束后，根据`flag`的值判断是否有序；有序，退出即可；

code:

```java
import java.util.Arrays;

public class code02 {

    public static void bubbleSort(int[] input){
        boolean isSorted = true;
        for(int i = 0; i< input.length-1; i++){
            for (int j = 0; j < input.length-1-i; j++){
                if(input[j] > input[j+1]){
                    int temp = input[j+1];
                    input[j+1] = input[j];
                    input[j] = temp;
                    isSorted = false;
                }
            }
            if (isSorted){
                break;
            }
        }
    }
    public static void main(String[] args) {
        int[] arr = {123,43,21,6,897,657,5,34,233};
        System.out.println("排序前数组："+ Arrays.toString(arr));
        bubbleSort(arr);
        System.out.println("排序后数组："+ Arrays.toString(arr));

    }
}
```

---------------



### 2.4 选择排序

**选择排序的算法**

1. 整个数列分成两部分：前面是有序数列，后面是无序数列
2. 初始状态下，整个数列都是无序的，有序数列是空
3. 一共n个数，需要n-1趟循环（一趟都不能少）
4. 每比较完一趟，有序数列数量+1，无序数列数量-1
5. 每趟先假设无序数列的第1个元素（整个数列的第i个元素）是最小的，让当前的最小数，从第i+1个元素开始比较，一直比较到最后一个元素。如果发现更小的数，就假设当前数是最小数。
6. 一趟比较完后，将发现最小数和无序数列的第一个数交换（如果最小数不是无序数列的第一个数）

**注意**

+ 冒泡排序最多需要n-1趟循环，最少1趟循环；选择排序必须进行n-1趟循环，一趟也不能少
+ 冒泡排序中最多的操作就是比较和交换，一趟循环中可能发生多次交换；而选择排序中最多的操作是比较，一趟比较结束后如果发现更小的值才交换一次。
+ 如果数组元素不是基本数据类型，而是对象，应该如何判断大小呢？可以让相应类实现Comparable接口并调用comparTo()方法进行比较。

code:

```java
import java.util.Arrays;

public class code03 {
    public static void selectSort(int[] scoreArr) {
        //大循环：n个元素排序，则需要n-1趟循环
        for (int i = 0; i < scoreArr.length - 1; i++) {
            //第i趟先假设第i个最小
            int minIndex = i;
            //从第i+1个元素开始，依次使用最小元素和每元素比较，一直比较到最后
            for (int j = i + 1; j < scoreArr.length; j++) {
                if (scoreArr[minIndex] > scoreArr[j]) {
                    minIndex = j;
                }
            }
            //一趟比较完后，或者最小值的索引，如果不是第i个，就交换
            if (minIndex != i) {
                int temp;
                temp = scoreArr[i];
                scoreArr[i] = scoreArr[minIndex];
                scoreArr[minIndex] = temp;
            }
        }
    }

    public static void main(String[] args) {
        
        int[] scoreArr = {75, 87, 56, 45, 89, 100, 76, 34, 89, 97};
        System.out.println(Arrays.toString(scoreArr));
        selectSort(scoreArr);
        System.out.println(Arrays.toString(scoreArr));

    }
}
```



### 2.5 快速排序

**快速排序的算法**

1. 选取中间轴P
2. 将大于P的数据放在P右边
3. 将小于P的数据放在P左边
4. 分别对左右子序列重复上述三步操作

**快速排序的具体过程**

1. 定义两个变量，left,right.分别指向数组的头和尾，（一般而言，我们选择头也就是arr[0]作为我们选定的中间轴P）。
2. 从right开始遍历直到找到小于P的元素，将这个元素的值赋给left指向的元素及arr[left] = arr[right]。
3. 从left开始，直到找到大于P的元素，然后将arr[right] = arr[left]
4. 重复2、3，最终left,right会指向同一个元素，这个元素就是中间轴P的插入位置。

图示：

![快速排序](https://img-blog.csdn.net/20150810110155861)

code:

```java
import java.util.Arrays;

public class code04 {
    /**
     * 快排算法
     * @param arr 需要排序的数组
     * @param left 数组头
     * @param right 数组尾
     */
    public static void quickSort(int[] arr, int left,int right){
        //递归结束条件
        if(left >= right){
            return;
        }

        int p = arr[left];//中心轴
        int l = left;//左指针
        int r = right;//右指针

        while (l < r){ //当左指针没遇到右指针
            //从右边开始判断
            while (l < r && arr[r] >= p){
                r--;
            }//循环结束后找到最后一个大于中心轴的元素，然后进行赋值
            if(l < r){//如果左右指针不相等则进行赋值，如果相等就找到p的位置,不用进行赋值
                arr[l] = arr[r];
            }

            //剩余的从左侧开始判断
            while (l < r && arr[l] <= p){
                l ++;
            }//循环结束后找到最后一个小于中心轴的元素，然后进行赋值
            if (l < r){//如果左右指针不相等则进行赋值，如果相等就找到p的位置,不用进行赋值
                arr[r] = arr[l];
            }

            //插入中心轴
            arr[l] = p;
            //此时中心轴左侧元素全部小于中心轴，中心轴右侧元素全部大于中心轴

            //继续对左右两边进行相同操作
            quickSort(arr,left,l-1);
            quickSort(arr,l+1,right);
        }
    }

    public static void main(String[] args) {
        int[] arr = {9,2,5,3,7,4,1,6,8};
        System.out.println(Arrays.toString(arr));
        quickSort(arr, 0, arr.length-1);
        System.out.println(Arrays.toString(arr));
    }
}
```

-------



### 2.6 递归

递归是一种常见的解决问题的方法，即把问题逐渐简单化。递归的基本思想就是“自己调用自己”，一个使用递归技术的方法将会直接或者间接的调用自己。利用递归可以用简单的程序来解决一些复杂的问题。比如：斐波那契数列的计算、汉诺塔、快速排序等问题。



### 2.7 循环与递归实现n!

循环实现

code:

```java
public class code05 {
    public static int fac(int n){
        int res = 1;
        for (int i = n; i > 0; i--){
            res *= i;
        }
        return res;
    }

    public static void main(String[] args) {
        System.out.println("5! = "+fac(5));
    }
}
```

递归实现

code:

```java
public class code06 {
    public static int fac(int n){
        if(n==1){ //递归的结束条件
            return 1;
        }else {
            return n*(fac(n-1));
        }
    }

    public static void main(String[] args) {
        System.out.println("6! ="+fac(6));
    }
}
```



### 2.8 循环与递归实现斐波那契数列

循环实现

code:

```java
public class code07 {
    public static int fibo(int N){
        if (N == 1||N==2){
            return 1;
        }
        int n__ = 1;
        int n_ = 1;
        int n = 2;
        for (int i = 3; i <= N; i++){
            n = n_+n__;
            n__ = n_;
            n_ = n;
        }
        return n;
    }

    public static void main(String[] args) {
        System.out.println("斐波那契数列的第1项="+fibo(1)+"\n斐波那契数列的第5项="+fibo(5));
    }
}
```

递归实现：

code:

```java
public class code08 {
    public static int fibo(int N){
        if (N == 1||N==2){ //递归结束条件
            return 1;
        }else{
            return fibo(N-2)+fibo(N-1);
        }
    }

    public static void main(String[] args) {
        System.out.println("斐波那契数列的第1项="+fibo(1)+"\n斐波那契数列的第5项="+fibo(5));
    }
}
```

### 2.9 递归总结

##### 递归问题的特点

+ 一个问题可被分解为若干层简单的子问题
+ 子问题和其上层问题的解决方案一致
+ 外层问题的解决依赖于子问题的解决

##### 递归的结构

+ 递归结束条件：什么时候不调用自身方法。如果没有条件，将陷入死循环。
+ 递归体：什么时候需要调用自身方法。

##### 递归的优点

自然的思路，简单的程序

##### 递归的缺点

+ 递归调用会占用大量的系统堆栈，内存耗用多，
+ 在递归调用层次多时速度要比循环慢的多

 

##### **注意事项**

+ 任何能用递归解决的问题也能使用迭代解决。当递归方法可以更加自然地反映问题，并且易于理解和调试，并且不强调效率问题时，可以采用递归。
+ 在要求高性能的情况下尽量避免使用递归，递归调用既花时间又耗内存。



### 2.10 折半查找

折半查找又称为二分查找，这种查找方法需要待查的查找表满足两个条件：

首先，查找表必须使用顺序存储结构；

其次，查找表必须按关键字大小有序排列。



**实现：**

循环实现

code:

```java
public class code09 {
    public static int BinSearch(int[] arr, int target){
        if(arr == null){
            return -1;
        }
        int start = 0;
        int end = arr.length-1;
        while (start <= end){
            int middle = (start+end)/2;
            int midVal = arr[middle];
            if (target == midVal){
                return middle;
            }else if(target < midVal){
                end = middle-1;
            }else {
                end = middle+1;
            }
        }
        return -1;
    }

    public static void main(String[] args) {
        int[] testArr = {2,54,23,4,7,8,34,5,99};
        System.out.println("testArr中7的位置是"+BinSearch(testArr,7));
    }
}
```

递归实现

code:

```java
public class code10 {
    public static int BinSearch(int[] arr, int target,int start,int end){
        if(arr == null || start>end){
            return -1;
        }
        int middle = (start+end)/2;
        int midVal = arr[middle];
        if (target == midVal){
            return middle;
        }else if(target < midVal){
            return BinSearch(arr,target,middle+1,end);
        }else {
            end = BinSearch(arr,target,start,middle-1);
        }
        return -1;
    }
    public static int BinSearch(int[] arr, int target){
        return BinSearch(arr,target,0,arr.length-1);
    }

    public static void main(String[] args) {
        int[] testArr = {2,54,23,4,7,8,34,5,99};
        System.out.println("testArr中7的位置是"+BinSearch(testArr,7));
    }
}
```